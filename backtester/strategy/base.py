"""Base strategy class for implementing trading strategies.

This module defines the abstract base class that all trading strategies should inherit from.
It provides the common interface and functionality required by the backtesting engine.
"""

import logging
from abc import ABC, abstractmethod
from typing import Any, TypeVar

import pandas as pd

T = TypeVar('T')


class BaseStrategy(ABC):
    """Abstract base class for all trading strategies."""

    def __init__(self, name: str, logger: logging.Logger | None = None) -> None:
        """Initialize the strategy.

        Args:
            name: Strategy name
            logger: Optional logger instance
        """
        self.name: str = name
        self.logger: logging.Logger = logger or logging.getLogger(__name__)
        self.current_step: int = 0
        self.signals: list[dict[str, Any]] = []
        self.positions: dict[str, Any] = {}

    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> list[dict[str, Any]]:
        """Generate trading signals based on market data.

        Args:
            data: DataFrame with market data

        Returns:
            List of signal dictionaries
        """
        pass

    @abstractmethod
    def get_required_columns(self) -> list[str]:
        """Get list of required data columns.

        Returns:
            List of column names that the strategy needs
        """
        pass

    def update_step(self, step: int) -> None:
        """Update the current strategy step.

        Args:
            step: Current time step
        """
        self.current_step = step

    def add_signal(self, signal: dict[str, Any]) -> None:
        """Add a signal to the strategy's signal list.

        Args:
            signal: Signal dictionary with signal information
        """
        self.signals.append(signal)
        self.logger.debug(f"Added signal: {signal}")

    def get_latest_signal(self) -> dict[str, Any] | None:
        """Get the most recent signal.

        Returns:
            Latest signal dictionary or None if no signals
        """
        return self.signals[-1] if self.signals else None

    def get_all_signals(self) -> list[dict[str, Any]]:
        """Get all signals generated by the strategy.

        Returns:
            List of all signals
        """
        return self.signals.copy()

    def reset(self) -> None:
        """Reset the strategy state."""
        self.current_step = 0
        self.signals.clear()
        self.positions.clear()
        self.logger.info(f"Strategy {self.name} reset")

    def validate_data(self, data: pd.DataFrame) -> bool:
        """Validate that data contains required columns.

        Args:
            data: DataFrame to validate

        Returns:
            True if data is valid, False otherwise
        """
        required_columns = self.get_required_columns()
        missing_columns = [col for col in required_columns if col not in data.columns]

        if missing_columns:
            self.logger.error(f"Strategy {self.name} requires columns: {missing_columns}")
            return False

        return True

    def get_strategy_parameters(self) -> dict[str, Any]:
        """Get strategy parameters.

        Returns:
            Dictionary of strategy parameters
        """
        return {"name": self.name}


class Signal:
    """Represents a trading signal."""

    def __init__(
        self,
        timestamp: Any,
        signal_type: str,
        price: float,
        quantity: float = 1.0,
        stop_loss: float | None = None,
        take_profit: float | None = None,
        metadata: dict[str, Any] | None = None,
    ) -> None:
        """Initialize a trading signal.

        Args:
            timestamp: Signal timestamp
            signal_type: Type of signal ('BUY', 'SELL', 'HOLD')
            price: Signal price
            quantity: Signal quantity (default 1.0)
            stop_loss: Optional stop loss price
            take_profit: Optional take profit price
            metadata: Additional signal metadata
        """
        self.timestamp: Any = timestamp
        self.signal_type: str = signal_type.upper()
        self.price: float = price
        self.quantity: float = quantity
        self.stop_loss: float | None = stop_loss
        self.take_profit: float | None = take_profit
        self.metadata: dict[str, Any] = metadata or {}

    def __repr__(self) -> str:
        """Return string representation of the Signal."""
        return f"Signal({self.signal_type}, {self.price}, {self.quantity}, ts={self.timestamp})"

    def to_dict(self) -> dict[str, Any]:
        """Convert signal to dictionary.

        Returns:
            Signal as dictionary
        """
        return {
            'timestamp': self.timestamp,
            'signal_type': self.signal_type,
            'price': self.price,
            'quantity': self.quantity,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'metadata': self.metadata,
        }
